<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Nearnomicon</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Implementation details of the NearProtocol client">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="index.html">Introduction</a></li><li class="expanded "><a href="BlockchainLayerVsRuntimeLayer.html"><strong aria-hidden="true">1.</strong> Blockchain Layer vs Runtime Layer</a></li><li class="expanded "><a href="Runtime/Runtime.html"><strong aria-hidden="true">2.</strong> Runtime</a></li><li><ol class="section"><li class="expanded "><a href="Runtime/Components/Components.html"><strong aria-hidden="true">2.1.</strong> Components</a></li><li><ol class="section"><li class="expanded "><a href="Runtime/Components/BindingsSpec/BindingsSpec.html"><strong aria-hidden="true">2.1.1.</strong> Bindings Specification</a></li><li><ol class="section"><li class="expanded "><a href="Runtime/Components/BindingsSpec/RegistersAPI.html"><strong aria-hidden="true">2.1.1.1.</strong> Registers API</a></li><li class="expanded "><a href="Runtime/Components/BindingsSpec/TrieAPI.html"><strong aria-hidden="true">2.1.1.2.</strong> Trie API</a></li><li class="expanded "><a href="Runtime/Components/BindingsSpec/PromisesAPI.html"><strong aria-hidden="true">2.1.1.3.</strong> Promises API</a></li><li class="expanded "><a href="Runtime/Components/BindingsSpec/ContextAPI.html"><strong aria-hidden="true">2.1.1.4.</strong> Context API</a></li><li class="expanded "><a href="Runtime/Components/BindingsSpec/EconomicsAPI.html"><strong aria-hidden="true">2.1.1.5.</strong> Economics API</a></li><li class="expanded "><a href="Runtime/Components/BindingsSpec/MathAPI.html"><strong aria-hidden="true">2.1.1.6.</strong> Math API</a></li><li class="expanded "><a href="Runtime/Components/BindingsSpec/MiscellaneousAPI.html"><strong aria-hidden="true">2.1.1.7.</strong> Miscellaneous API</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Nearnomicon</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-nearnomicon" id="the-nearnomicon">The Nearnomicon</a></h1>
<p>Nearnomicon contains the following information about the components of the NearProtocol client, with the goal to help
with the collaboration:</p>
<ul>
<li>High-level overview of the components and how they interact, including APIs;</li>
<li>Data-structures;</li>
<li>Things that are not yet implemented or replaced with temporary solutions;</li>
<li>Assumptions that each component makes.</li>
</ul>
<h1><a class="header" href="#blockchain-layer-vs-runtime-layer" id="blockchain-layer-vs-runtime-layer">Blockchain Layer vs Runtime Layer</a></h1>
<p>Near node consists roughly of a blockchain layer and a runtime layer.
These layers are designed to be independent from each other: the blockchain layer can in theory support runtime that processes
transactions differently, has a different virtual machine (e.g. RISC-V), has different fees; on the other hand the runtime
is oblivious to where the transactions are coming from. It is not aware whether the
blockchain it runs on is sharded, what consensus it uses, and whether it runs as part of a blockchain at all.</p>
<p>The blockchain layer and the runtime layer share the following components and invariants:</p>
<h2><a class="header" href="#transactions-and-receipts" id="transactions-and-receipts">Transactions and Receipts</a></h2>
<p>Transactions and receipts are a fundamental concept in Near Protocol. Transactions represent actions requested by the
blockchain user, e.g. send assets, create account, execute a method, etc. Receipts, on the other hand is an internal
structure; think of a receipt as a message which is used inside a message-passing system.</p>
<p>Transactions are created outside the Near Protocol node, by the user who sends them via RPC or network communication.
Receipts are created by the runtime from transactions or as the result of processing other receipts.</p>
<p>Blockchain layer cannot create or process transactions and receipts, it can only manipulate them by passing them
around and feeding them to a runtime.</p>
<h2><a class="header" href="#account-based-system" id="account-based-system">Account-Based System</a></h2>
<p>Similar to Ethereum, Near Protocol is an account-based system. Which means that each blockchain user is roughly
associated with one or several accounts (there are exceptions though, when users share an account and are separated
through the access keys).</p>
<p>The runtime is essentially a complex set of rules on what to do with accounts based on the information from the
transactions and the receipts. It is therefore deeply aware of the concept of account. </p>
<p>Blockchain layer however is mostly aware of the accounts through the trie (see below) and the validators (see below).
Outside these two it does not operate on the accounts directly.</p>
<h2><a class="header" href="#trie" id="trie">Trie</a></h2>
<p>Near Protocol is a stateful blockchain -- there is a state associated with each account and the user actions performed
through transactions mutate that state. The state then is stored as a trie, and both the blockchain layer and the
runtime layer are aware of this technical detail.</p>
<p>The blockchain layer manipulates the trie directly. It partitions the trie between the shards to distribute the load.
It synchronizes the trie between the nodes, and eventually it is responsible for maintaining the consistency of the trie
between the nodes through its consensus mechanism and other game-theoretic methods.</p>
<p>The runtime layer is also aware that the storage that it uses to perform the operations on is a trie. In general it does
not have to know this technical detail and in theory we could have abstracted out the trie as a generic key-value storage.
However, we allow some trie-specific operations that we expose to the smart contract developers so that they utilize
Near Protocol to its maximum efficiency.</p>
<h2><a class="header" href="#tokens-and-gas" id="tokens-and-gas">Tokens and gas</a></h2>
<p>Even though tokens is a fundamental concept of the blockchain, it is neatly encapsulated
inside the runtime layer together with the gas, fees, and rewards.</p>
<p>The only way the blockchain layer is aware of the tokens and the gas is through the computation of the exchange rate
and the inflation which is based strictly on the block production mechanics.</p>
<h2><a class="header" href="#validators" id="validators">Validators</a></h2>
<p>Both the blockchain layer and the runtime layer are aware of a special group of participants who are
responsible for maintaining the integrity of the Near Protocol. These participants are associated with the
accounts and are rewarded accordingly. The reward part is what the runtime layer is aware of, while everything
around the orchestration of the validators is inside the blockchain layer.</p>
<h2><a class="header" href="#blockchain-layer-concepts" id="blockchain-layer-concepts">Blockchain Layer Concepts</a></h2>
<p>Interestingly, the following concepts are for the blockchain layer only and the runtime layer is not aware of them:</p>
<ul>
<li>Sharding -- the runtime layer does not know that it is being used in a sharded blockchain, e.g. it does not know
that the trie it works on is only a part of the overall blockchain state;</li>
<li>Blocks or chunks -- the runtime does not know that the receipts that it processes constitute a chunk and that the output
receipts will be used in other chunks. From the runtime perspective it consumes and outputs batches of transactions and receipts;</li>
<li>Consensus -- the runtime does not know how consistency of the state is maintained;</li>
<li>Communication -- the runtime does not know where transactions and receipts are coming from and where they are going to.</li>
</ul>
<h2><a class="header" href="#runtime-layer-concepts" id="runtime-layer-concepts">Runtime Layer Concepts</a></h2>
<ul>
<li>Fees and rewards -- fees and rewards are neatly encapsulated in the runtime layer. The blockchain layer, however
has an indirect knowledge of them through the computation of the tokens-to-gas exchange rate and the inflation.</li>
</ul>
<h1><a class="header" href="#runtime" id="runtime">Runtime</a></h1>
<p>Runtime layer is used to execute smart contracts and other actions created by the users and preserve the state between the executions.
It can be described from three different angles: going step-by-step through various scenarios, describing the components
of the runtime, and describing the functions that the runtime performs.</p>
<h2><a class="header" href="#scenarios" id="scenarios">Scenarios</a></h2>
<ul>
<li>Financial transaction -- we examine what happens when the runtime needs to process a simple financial transaction;</li>
<li>Contract call transaction -- the scenario when the user calls a contract.</li>
</ul>
<h2><a class="header" href="#components" id="components">Components</a></h2>
<p>The components of the runtime can be described through the crates:</p>
<ul>
<li><code>near-vm-logic</code> -- describes the interface that smart contract uses to interact with the blockchain.
Encapsulates the behavior of the blockchain visible to the smart contract, e.g. fee rules, storage access rules, promise rules;</li>
<li><code>near-vm-runner</code> crate -- a wrapper around Wasmer that does the actual execution of the smart contract code. It exposes the
interface provided by <code>near-vm-logic</code> to the smart contract;</li>
<li><code>runtime</code> crate -- encapsulates the logic of how transactions and receipts should be handled. If it encounters
a smart contract call within a transaction or a receipt it calls <code>near-vm-runner</code>, for all other actions, like account
creation, it processes them in-place.</li>
</ul>
<p>The utility crates are:</p>
<ul>
<li><code>near-runtime-fees</code> -- a convenience crate that encapsulates configuration of fees. We might get rid ot it later;</li>
<li><code>near-vm-errors</code> -- contains the hierarchy of errors that can be occurred during transaction or receipt processing;</li>
<li><code>near-vm-runner-standalone</code> -- a runnable tool that allows running the runtime without the blockhain, e.g. for
integration testing of L2 projects;</li>
<li><code>runtime-params-estimator</code> -- bechmarks the runtime and generates the config with the fees.</li>
</ul>
<p>Separately, from the components we describe <a href="Runtime/BindingsSpec/BindingsSpec.html">the Bindings Specification</a> which is an
important part of the runtime that specifies the functions that the smart contract can call from its host -- the runtime.
The specification is defined in <code>near-vm-logic</code>, but it is exposed to the smart contract in <code>near-vm-runner</code>.</p>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<ul>
<li>Receipt consumption and production</li>
<li>Fees</li>
<li>Virtual machine</li>
<li>Verification</li>
</ul>
<h1><a class="header" href="#components-1" id="components-1">Components</a></h1>
<p>Here is the high-level diagram of various runtime components, including some blockchain layer components.
<img src="Runtime/Components/../../images/runtime_architecture.svg" /></p>
<h1><a class="header" href="#bindings-specification" id="bindings-specification">Bindings Specification</a></h1>
<p>This is the low-level interface available to the smart contracts, it consists of the functions that the host (represented by
Wasmer inside near-vm-runner) exposes to the guest (the smart contract compiled to Wasm).</p>
<p>Due to Wasm restrictions the methods operate only with primitive types, like <code>u64</code>.</p>
<p>Also for all functions in the bindings specification the following is true:</p>
<ul>
<li>Method execution could result in <code>MemoryAccessViolation</code> error if one of the following happens:
<ul>
<li>The method causes host to read a piece of memory from the guest but it points outside the guest's memory;</li>
<li>The guest causes host to read from the register, but register id is invalid.</li>
</ul>
</li>
</ul>
<p>Execution of a bindings function call result in an error being generated. This error causes execution of the smart contract
to be terminated and the error message written into the logs of the transaction that caused the execution. Many bindings
functions can throw specialized error messages, but there is also a list of error messages that can be thrown by almost
any function:</p>
<ul>
<li><code>IntegerOverflow</code> -- happens when guest passes some data to the host but when host tries to apply arithmetic operation
on it it causes overflow or underflow;</li>
<li><code>GasExceeded</code> -- happens when operation performed by the guest causes more gas than the remaining prepaid gas;</li>
<li><code>GasLimitExceeded</code> -- happens when the execution uses more gas than allowed by the global limit imposed in the economics
config;</li>
<li><code>StorageError</code> -- happens when method fails to do some operation on the trie.</li>
</ul>
<p>The following binding methods cannot be invoked in a view call:</p>
<ul>
<li><code>signer_account_id</code></li>
<li><code>signer_account_pk</code></li>
<li><code>predecessor_account_id</code></li>
<li><code>attached_deposit</code></li>
<li><code>prepaid_gas</code></li>
<li><code>used_gas</code></li>
<li><code>promise_create</code></li>
<li><code>promise_then</code></li>
<li><code>promise_and</code></li>
<li><code>promise_batch_create</code></li>
<li><code>promise_batch_then</code></li>
<li><code>promise_batch_action_create_account</code></li>
<li><code>promise_batch_action_deploy_account</code></li>
<li><code>promise_batch_action_function_call</code></li>
<li><code>promise_batch_action_transfer</code></li>
<li><code>promise_batch_action_stake</code></li>
<li><code>promise_batch_action_add_key_with_full_access</code></li>
<li><code>promise_batch_action_add_key_with_function_call</code></li>
<li><code>promise_batch_action_delete_key</code></li>
<li><code>promise_batch_action_delete_account</code></li>
<li><code>promise_results_count</code></li>
<li><code>promise_result</code></li>
<li><code>promise_return</code></li>
</ul>
<p>If they are invoked the smart contract execution will panic with <code>ProhibitedInView(&lt;method name&gt;)</code>.</p>
<h1><a class="header" href="#registers-api" id="registers-api">Registers API</a></h1>
<p>Registers allow the host function to return the data into a buffer located inside the host oppose to the buffer
located on the client. A special operation can be used to copy the content of the buffer into the host. Memory pointers
can then be used to point either to the memory on the guest or the memory on the host, see below. Benefits:</p>
<ul>
<li>We can have functions that return values that are not necessarily used, e.g. inserting key-value into a trie can
also return the preempted old value, which might not be necessarily used. Previously, if we returned something we
would have to pass the blob from host into the guest, even if it is not used;</li>
<li>We can pass blobs of data between host functions without going through the guest, e.g. we can remove the value
from the storage and insert it into under a different key;</li>
<li>It makes API cleaner, because we don't need to pass <code>buffer_len</code> and <code>buffer_ptr</code> as arguments to other functions;</li>
<li>It allows merging certain functions together, see <code>storage_iter_next</code>;</li>
<li>This is consistent with other APIs that were created for high performance, e.g. allegedly Ewasm have implemented
SNARK-like computations in Wasm by exposing a bignum library through stack-like interface to the guest. The guest
can manipulate then with the stack of 256-bit numbers that is located on the host.</li>
</ul>
<h4><a class="header" href="#host--host-blob-passing" id="host--host-blob-passing">Host â†’ host blob passing</a></h4>
<p>The registers can be used to pass the blobs between host functions. For any function that
takes a pair of arguments <code>*_len: u64, *_ptr: u64</code> this pair is pointing to a region of memory either on the guest or
the host:</p>
<ul>
<li>If <code>*_len != u64::MAX</code> it points to the memory on the guest;</li>
<li>If <code>*_len == u64::MAX</code> it points to the memory under the register <code>*_ptr</code> on the host.</li>
</ul>
<p>For example:
<code>storage_write(u64::MAX, 0, u64::MAX, 1, 2)</code> -- insert key-value into storage, where key is read from register 0,
value is read from register 1, and result is saved to register 2.</p>
<p>Note, if some function takes <code>register_id</code> then it means this function can copy some data into this register. If
<code>register_id == u64::MAX</code> then the copying does not happen. This allows some micro-optimizations in the future.</p>
<p>Note, we allow multiple registers on the host, identified with <code>u64</code> number. The guest does not have to use them in
order and can for instance save some blob in register <code>5000</code> and another value in register <code>1</code>.</p>
<h4><a class="header" href="#specification" id="specification">Specification</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>read_register(register_id: u64, ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Writes the entire content from the register <code>register_id</code> into the memory of the guest starting with <code>ptr</code>.</p>
<h6><a class="header" href="#panics" id="panics">Panics</a></h6>
<ul>
<li>If the content extends outside the memory allocated to the guest. In Wasmer, it returns <code>MemoryAccessViolation</code> error message;</li>
<li>If <code>register_id</code> is pointing to unused register returns <code>InvalidRegisterId</code> error message.</li>
</ul>
<h6><a class="header" href="#undefined-behavior" id="undefined-behavior">Undefined Behavior</a></h6>
<ul>
<li>If the content of register extends outside the preallocated memory on the host side, or the pointer points to a
wrong location this function will overwrite memory that it is not supposed to overwrite causing an undefined behavior.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>register_len(register_id: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Returns the size of the blob stored in the given register.</p>
<h6><a class="header" href="#normal-operation" id="normal-operation">Normal operation</a></h6>
<ul>
<li>If register is used, then returns the size, which can potentially be zero;</li>
<li>If register is not used, returns <code>u64::MAX</code></li>
</ul>
<h1><a class="header" href="#trie-api" id="trie-api">Trie API</a></h1>
<p>Here we provide a specification of trie API. After this NEP is merged, the cases where our current implementation does
not follow the specification are considered to be bugs that need to be fixed.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_write(key_len: u64, key_ptr: u64, value_len: u64, value_ptr: u64, register_id: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Writes key-value into storage.</p>
<h6><a class="header" href="#normal-operation-1" id="normal-operation-1">Normal operation</a></h6>
<ul>
<li>If key is not in use it inserts the key-value pair and does not modify the register;</li>
<li>If key is in use it inserts the key-value and copies the old value into the <code>register_id</code>.</li>
</ul>
<h6><a class="header" href="#returns" id="returns">Returns</a></h6>
<ul>
<li>If key was not used returns <code>0</code>;</li>
<li>If key was used returns <code>1</code>.</li>
</ul>
<h6><a class="header" href="#panics-1" id="panics-1">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> or <code>value_len + value_ptr</code> exceeds the memory container or points to an unused register it panics
with <code>MemoryAccessViolation</code>. (When we say that something panics with the given error we mean that we use Wasmer API to
create this error and terminate the execution of VM. For mocks of the host that would only cause a non-name panic.)</li>
<li>If returning the preempted value into the registers exceed the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs" id="current-bugs">Current bugs</a></h6>
<ul>
<li><code>External::storage_set</code> trait can return an error which is then converted to a generic non-descriptive
<code>StorageUpdateError</code>, <a href="https://github.com/nearprotocol/nearcore/blob/942bd7bdbba5fb3403e5c2f1ee3c08963947d0c6/runtime/wasm/src/runtime.rs#L210">here</a>
however the actual implementation does not return error at all, <a href="https://github.com/nearprotocol/nearcore/blob/4773873b3cd680936bf206cebd56bdc3701ddca9/runtime/runtime/src/ext.rs#L95">see</a>;</li>
<li>Does not return into the registers.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_read(key_len: u64, key_ptr: u64, register_id: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Reads the value stored under the given key.</p>
<h6><a class="header" href="#normal-operation-2" id="normal-operation-2">Normal operation</a></h6>
<ul>
<li>If key is used copies the content of the value into the <code>register_id</code>, even if the content is zero bytes;</li>
<li>If key is not present then does not modify the register.</li>
</ul>
<h6><a class="header" href="#returns-1" id="returns-1">Returns</a></h6>
<ul>
<li>If key was not present returns <code>0</code>;</li>
<li>If key was present returns <code>1</code>.</li>
</ul>
<h6><a class="header" href="#panics-2" id="panics-2">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
<li>If returning the preempted value into the registers exceed the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs-1" id="current-bugs-1">Current bugs</a></h6>
<ul>
<li>This function currently does not exist.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_remove(key_len: u64, key_ptr: u64, register_id: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Removes the value stored under the given key.</p>
<h6><a class="header" href="#normal-operation-3" id="normal-operation-3">Normal operation</a></h6>
<p>Very similar to <code>storage_read</code>:</p>
<ul>
<li>If key is used, removes the key-value from the trie and copies the content of the value into the <code>register_id</code>, even if the content is zero bytes.</li>
<li>If key is not present then does not modify the register.</li>
</ul>
<h6><a class="header" href="#returns-2" id="returns-2">Returns</a></h6>
<ul>
<li>If key was not present returns <code>0</code>;</li>
<li>If key was present returns <code>1</code>.</li>
</ul>
<h6><a class="header" href="#panics-3" id="panics-3">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If returning the preempted value into the registers exceed the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs-2" id="current-bugs-2">Current bugs</a></h6>
<ul>
<li>Does not return into the registers.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_has_key(key_len: u64, key_ptr: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Checks if there is a key-value pair.</p>
<h6><a class="header" href="#normal-operation-4" id="normal-operation-4">Normal operation</a></h6>
<ul>
<li>If key is used returns <code>1</code>, even if the value is zero bytes;</li>
<li>Otherwise returns <code>0</code>.</li>
</ul>
<h6><a class="header" href="#panics-4" id="panics-4">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> exceeds the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_iter_prefix(prefix_len: u64, prefix_ptr: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Creates an iterator object inside the host.
Returns the identifier that uniquely differentiates the given iterator from other iterators that can be simultaneously
created.</p>
<h6><a class="header" href="#normal-operation-5" id="normal-operation-5">Normal operation</a></h6>
<ul>
<li>It iterates over the keys that have the provided prefix. The order of iteration is defined by the lexicographic
order of the bytes in the keys. If there are no keys, it creates an empty iterator, see below on empty iterators;</li>
</ul>
<h6><a class="header" href="#panics-5" id="panics-5">Panics</a></h6>
<ul>
<li>If <code>prefix_len + prefix_ptr</code> exceeds the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_iter_range(start_len: u64, start_ptr: u64, end_len: u64, end_ptr: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Similarly to <code>storage_iter_prefix</code>
creates an iterator object inside the host.</p>
<h6><a class="header" href="#normal-operation-6" id="normal-operation-6">Normal operation</a></h6>
<p>Unless lexicographically <code>start &lt; end</code>, it creates an empty iterator.
Iterates over all key-values such that keys are between <code>start</code> and <code>end</code>, where <code>start</code> is inclusive and <code>end</code> is exclusive.</p>
<p>Note, this definition allows for <code>start</code> or <code>end</code> keys to not actually exist on the given trie.</p>
<h6><a class="header" href="#panics-6" id="panics-6">Panics:</a></h6>
<ul>
<li>If <code>start_len + start_ptr</code> or <code>end_len + end_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_iter_next(iterator_id: u64, key_register_id: u64, value_register_id: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Advances iterator and saves the next key and value in the register.</p>
<h6><a class="header" href="#normal-operation-7" id="normal-operation-7">Normal operation</a></h6>
<ul>
<li>If iterator is not empty (after calling next it points to a key-value), copies the key into <code>key_register_id</code> and value into <code>value_register_id</code> and returns <code>1</code>;</li>
<li>If iterator is empty returns <code>0</code>.</li>
</ul>
<p>This allows us to iterate over the keys that have zero bytes stored in values.</p>
<h6><a class="header" href="#panics-7" id="panics-7">Panics</a></h6>
<ul>
<li>If <code>key_register_id == value_register_id</code> panics with <code>MemoryAccessViolation</code>;</li>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If <code>iterator_id</code> does not correspond to an existing iterator panics with  <code>InvalidIteratorId</code></li>
<li>If between the creation of the iterator and calling <code>storage_iter_next</code> any modification to storage was done through
<code>storage_write</code> or <code>storage_remove</code> the iterator is invalidated and the error message is <code>IteratorWasInvalidated</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-3" id="current-bugs-3">Current bugs</a></h6>
<ul>
<li>Not implemented, currently we have <code>storage_iter_next</code> and <code>data_read</code> + <code>DATA_TYPE_STORAGE_ITER</code> that together fulfill
the purpose, but have unspecified behavior.</li>
</ul>
<h1><a class="header" href="#promises-api" id="promises-api">Promises API</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_create(account_id_len: u64,
               account_id_ptr: u64,
               method_name_len: u64,
               method_name_ptr: u64,
               arguments_len: u64,
               arguments_ptr: u64,
               amount_ptr: u64,
               gas: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Creates a promise that will execute a method on account with given arguments and attaches the given amount.
<code>amount_ptr</code> point to slices of bytes representing <code>u128</code>.</p>
<h6><a class="header" href="#panics-8" id="panics-8">Panics</a></h6>
<ul>
<li>If <code>account_id_len + account_id_ptr</code> or <code>method_name_len + method_name_ptr</code> or <code>arguments_len + arguments_ptr</code>
or <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-3" id="returns-3">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_then(promise_idx: u64,
             account_id_len: u64,
             account_id_ptr: u64,
             method_name_len: u64,
             method_name_ptr: u64,
             arguments_len: u64,
             arguments_ptr: u64,
             amount_ptr: u64,
             gas: u64) -&gt; u64            
<span class="boring">}
</code></pre></pre>
<p>Attaches the callback that is executed after promise pointed by <code>promise_idx</code> is complete.</p>
<h6><a class="header" href="#panics-9" id="panics-9">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If <code>account_id_len + account_id_ptr</code> or <code>method_name_len + method_name_ptr</code> or <code>arguments_len + arguments_ptr</code>
or <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-4" id="returns-4">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_and(promise_idx_ptr: u64, promise_idx_count: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Creates a new promise which completes when time all promises passed as arguments complete. Cannot be used with registers.
<code>promise_idx_ptr</code> points to an array of <code>u64</code> elements, with <code>promise_idx_count</code> denoting the number of elements.
The array contains indices of promises that need to be waited on jointly.</p>
<h6><a class="header" href="#panics-10" id="panics-10">Panics</a></h6>
<ul>
<li>If <code>promise_ids_ptr + 8 * promise_idx_count</code> extend outside the guest memory with <code>MemoryAccessViolation</code>;</li>
<li>If any of the promises in the array do not correspond to existing promises panics with <code>InvalidPromiseIndex</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-5" id="returns-5">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_results_count() -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>If the current function is invoked by a callback we can access the execution results of the promises that
caused the callback. This function returns the number of complete and incomplete callbacks.</p>
<p>Note, we are only going to have incomplete callbacks once we have <code>promise_or</code> combinator.</p>
<h6><a class="header" href="#normal-execution" id="normal-execution">Normal execution</a></h6>
<ul>
<li>If there is only one callback <code>promise_results_count()</code> returns <code>1</code>;</li>
<li>If there are multiple callbacks (e.g. created through <code>promise_and</code>) <code>promise_results_count()</code> returns their number.</li>
<li>If the function was called not through the callback <code>promise_results_count()</code> returns <code>0</code>.</li>
</ul>
<h6><a class="header" href="#panics-11" id="panics-11">Panics</a></h6>
<ul>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_result(result_idx: u64, register_id: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>If the current function is invoked by a callback we can access the execution results of the promises that
caused the callback. This function returns the result in blob format and places it into the register.</p>
<h6><a class="header" href="#normal-execution-1" id="normal-execution-1">Normal execution</a></h6>
<ul>
<li>If promise result is complete and successful copies its blob into the register;</li>
<li>If promise result is complete and failed or incomplete keeps register unused;</li>
</ul>
<h6><a class="header" href="#returns-6" id="returns-6">Returns</a></h6>
<ul>
<li>If promise result is not complete returns <code>0</code>;</li>
<li>If promise result is complete and successful returns <code>1</code>;</li>
<li>If promise result is complete and failed returns <code>2</code>.</li>
</ul>
<h6><a class="header" href="#panics-12" id="panics-12">Panics</a></h6>
<ul>
<li>If <code>result_idx</code> does not correspond to an existing result panics with <code>InvalidResultIndex</code>.</li>
<li>If copying the blob exhausts the memory limit it panics with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-4" id="current-bugs-4">Current bugs</a></h6>
<ul>
<li>We currently have two separate functions to check for result completion and copy it.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_return(promise_idx: u64)
<span class="boring">}
</code></pre></pre>
<p>When promise <code>promise_idx</code> finishes executing its result is considered to be the result of the current function.</p>
<h6><a class="header" href="#panics-13" id="panics-13">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-5" id="current-bugs-5">Current bugs</a></h6>
<ul>
<li>The current name <code>return_promise</code> is inconsistent with the naming convention of Promise API.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_create(account_id_len: u64, account_id_ptr: u64) -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Creates a new promise towards given <code>account_id</code> without any actions attached to it.</p>
<h6><a class="header" href="#panics-14" id="panics-14">Panics</a></h6>
<ul>
<li>If <code>account_id_len + account_id_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-7" id="returns-7">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_then(promise_idx: u64, account_id_len: u64, account_id_ptr: u64) -&gt; u64            
<span class="boring">}
</code></pre></pre>
<p>Attaches a new empty promise that is executed after promise pointed by <code>promise_idx</code> is complete.</p>
<h6><a class="header" href="#panics-15" id="panics-15">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If <code>account_id_len + account_id_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-8" id="returns-8">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_create_account(promise_idx: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>CreateAccount</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R48</p>
<h6><a class="header" href="#panics-16" id="panics-16">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_deploy_contract(promise_idx: u64, code_len: u64, code_ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>DeployContract</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R49</p>
<h6><a class="header" href="#panics-17" id="panics-17">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>code_len + code_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_function_call(promise_idx: u64,
                                   method_name_len: u64,
                                   method_name_ptr: u64,
                                   arguments_len: u64,
                                   arguments_ptr: u64,
                                   amount_ptr: u64,
                                   gas: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>FunctionCall</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R50</p>
<p><em>NOTE: Calling <code>promise_batch_create</code> and then <code>promise_batch_action_function_call</code> will produce the same promise as calling <code>promise_create</code> directly.</em></p>
<h6><a class="header" href="#panics-18" id="panics-18">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>account_id_len + account_id_ptr</code> or <code>method_name_len + method_name_ptr</code> or <code>arguments_len + arguments_ptr</code>
or <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_transfer(promise_idx: u64, amount_ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>Transfer</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R51</p>
<h6><a class="header" href="#panics-19" id="panics-19">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_stake(promise_idx: u64,
                           amount_ptr: u64,
                           bls_public_key_len: u64,
                           bls_public_key_ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>Stake</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R52</p>
<h6><a class="header" href="#panics-20" id="panics-20">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given BLS public key is not a valid BLS public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>If <code>amount_ptr + 16</code> or <code>bls_public_key_len + bls_public_key_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_add_key_with_full_access(promise_idx: u64,
                                              public_key_len: u64,
                                              public_key_ptr: u64,
                                              nonce: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>AddKey</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R54
The access key will have <code>FullAccess</code> permission, details: https://github.com/nearprotocol/NEPs/blob/master/text/0005-access-keys.md#guide-level-explanation</p>
<h6><a class="header" href="#panics-21" id="panics-21">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given public key is not a valid public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>If <code>public_key_len + public_key_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_add_key_with_function_call(promise_idx: u64,
                                                public_key_len: u64,
                                                public_key_ptr: u64,
                                                nonce: u64,
                                                allowance_ptr: u64,
                                                receiver_id_len: u64,
                                                receiver_id_ptr: u64,
                                                method_names_len: u64,
                                                method_names_ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>AddKey</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-156752ec7d78e7b85b8c7de4a19cbd4R54
The access key will have <code>FunctionCall</code> permission, details: https://github.com/nearprotocol/NEPs/blob/master/text/0005-access-keys.md#guide-level-explanation</p>
<ul>
<li>If the <code>allowance</code> value (not the pointer) is <code>0</code>, the allowance is set to <code>None</code> (which means unlimited allowance). And positive value represents a <code>Some(...)</code> allowance.</li>
<li>Given <code>method_names</code> is a <code>utf-8</code> string with <code>,</code> used as a separator. The vm will split the given string into a vector of strings.</li>
</ul>
<h6><a class="header" href="#panics-22" id="panics-22">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given public key is not a valid public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>if <code>method_names</code> is not a valid <code>utf-8</code> string, fails with <code>BadUTF8</code>.</li>
<li>If <code>public_key_len + public_key_ptr</code>, <code>allowance_ptr + 16</code>, <code>receiver_id_len + receiver_id_ptr</code> or 
<code>method_names_len + method_names_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_delete_key(promise_idx: u64,
                                public_key_len: u64,
                                public_key_ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>DeleteKey</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R55</p>
<h6><a class="header" href="#panics-23" id="panics-23">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given public key is not a valid public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>If <code>public_key_len + public_key_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>promise_batch_action_delete_account(promise_idx: u64,
                                    beneficiary_id_len: u64,
                                    beneficiary_id_ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Appends <code>DeleteAccount</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Action is used to delete an account. It can be performed on a newly created account, on your own account or an account with
insufficient funds to pay rent. Takes <code>beneficiary_id</code> to indicate where to send the remaining funds.</p>
<h6><a class="header" href="#panics-24" id="panics-24">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>beneficiary_id_len + beneficiary_id_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h1><a class="header" href="#context-api" id="context-api">Context API</a></h1>
<p>Context API mostly provides read-only functions that access current information about the blockchain, the accounts
(that originally initiated the chain of cross-contract calls, the immediate contract that called the current one, the account of the current contract),
other important information like storage usage.</p>
<p>Many of the below functions are currently implemented through <code>data_read</code> which allows to read generic context data.
However, there is no reason to have <code>data_read</code> instead of the specific functions:</p>
<ul>
<li><code>data_read</code> does not solve forward compatibility. If later we want to add another context function, e.g. <code>executed_operations</code>
we can just declare it as a new function, instead of encoding it as <code>DATA_TYPE_EXECUTED_OPERATIONS = 42</code> which is passed
as the first argument to <code>data_read</code>;</li>
<li><code>data_read</code> does not help with renaming. If later we decide to rename <code>signer_account_id</code> to <code>originator_id</code> then one could
argue that contracts that rely on <code>data_read</code> would not break, while contracts relying on <code>signer_account_id()</code> would. However
the name change often means the change of the semantics, which means the contracts using this function are no longer safe to
execute anyway.</li>
</ul>
<p>However there is one reason to not have <code>data_read</code> -- it makes <code>API</code> more human-like which is a general direction Wasm APIs, like WASI are moving towards to.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>current_account_id(register_id: u64)
<span class="boring">}
</code></pre></pre>
<p>Saves the account id of the current contract that we execute into the register.</p>
<h6><a class="header" href="#panics-25" id="panics-25">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>signer_account_id(register_id: u64)
<span class="boring">}
</code></pre></pre>
<p>All contract calls are a result of some transaction that was signed by some account using
some access key and submitted into a memory pool (either through the wallet using RPC or by a node itself). This function returns the id of that account.</p>
<h6><a class="header" href="#normal-operation-8" id="normal-operation-8">Normal operation</a></h6>
<ul>
<li>Saves the bytes of the signer account id into the register.</li>
</ul>
<h6><a class="header" href="#panics-26" id="panics-26">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-6" id="current-bugs-6">Current bugs</a></h6>
<ul>
<li>Currently we conflate <code>originator_id</code> and <code>sender_id</code> in our code base.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>signer_account_pk(register_id: u64)
<span class="boring">}
</code></pre></pre>
<p>Saves the public key fo the access key that was used by the signer into the register.
In rare situations smart contract might want to know the exact access key that was used to send the original transaction,
e.g. to increase the allowance or manipulate with the public key.</p>
<h6><a class="header" href="#panics-27" id="panics-27">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-7" id="current-bugs-7">Current bugs</a></h6>
<ul>
<li>Not implemented.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>predecessor_account_id(register_id: u64)
<span class="boring">}
</code></pre></pre>
<p>All contract calls are a result of a receipt, this receipt might be created by a transaction
that does function invocation on the contract or another contract as a result of cross-contract call.</p>
<h6><a class="header" href="#normal-operation-9" id="normal-operation-9">Normal operation</a></h6>
<ul>
<li>Saves the bytes of the predecessor account id into the register.</li>
</ul>
<h6><a class="header" href="#panics-28" id="panics-28">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-8" id="current-bugs-8">Current bugs</a></h6>
<ul>
<li>Not implemented.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>input(register_id: u64)
<span class="boring">}
</code></pre></pre>
<p>Reads input to the contract call into the register. Input is expected to be in JSON-format.</p>
<h6><a class="header" href="#normal-operation-10" id="normal-operation-10">Normal operation</a></h6>
<ul>
<li>If input is provided saves the bytes (potentially zero) of input into register.</li>
<li>If input is not provided does not modify the register.</li>
</ul>
<h6><a class="header" href="#returns-9" id="returns-9">Returns</a></h6>
<ul>
<li>If input was not provided returns <code>0</code>;</li>
<li>If input was provided returns <code>1</code>; If input is zero bytes returns <code>1</code>, too.</li>
</ul>
<h6><a class="header" href="#panics-29" id="panics-29">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs-9" id="current-bugs-9">Current bugs</a></h6>
<ul>
<li>Implemented as part of <code>data_read</code>. However there is no reason to have one unified function, like <code>data_read</code> that can
be used to read all</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>block_index() -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Returns the current block index.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>storage_usage() -&gt; u64
<span class="boring">}
</code></pre></pre>
<p>Returns the number of bytes used by the contract if it was saved to the trie as of the
invocation. This includes:</p>
<ul>
<li>The data written with <code>storage_*</code> functions during current and previous execution;</li>
<li>The bytes needed to store the account protobuf and the access keys of the given account.</li>
</ul>
<h1><a class="header" href="#economics-api" id="economics-api">Economics API</a></h1>
<p>Accounts own certain balance; and each transaction and each receipt have certain amount of balance and prepaid gas
attached to them.
During the contract execution, the contract has access to the following <code>u128</code> values:</p>
<ul>
<li><code>account_balance</code> -- the balance attached to the given account. This includes the <code>attached_deposit</code> that was attached
to the transaction;</li>
<li><code>attached_deposit</code> -- the balance that was attached to the call that will be immediately deposited before
the contract execution starts;</li>
<li><code>prepaid_gas</code> -- the tokens attached to the call that can be used to pay for the gas;</li>
<li><code>used_gas</code> -- the gas that was already burnt during the contract execution and attached to promises (cannot exceed <code>prepaid_gas</code>);</li>
</ul>
<p>If contract execution fails <code>prepaid_gas - used_gas</code> is refunded back to <code>signer_account_id</code> and <code>attached_deposit</code>
is refunded back to <code>predecessor_account_id</code>.</p>
<p>The following spec is the same for all functions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>account_balance(balance_ptr: u64)
attached_deposit(balance_ptr: u64)

<span class="boring">}
</code></pre></pre>
<p>-- writes the value into the <code>u128</code> variable pointed by <code>balance_ptr</code>.</p>
<h6><a class="header" href="#panics-30" id="panics-30">Panics</a></h6>
<ul>
<li>If <code>balance_ptr + 16</code> points outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-10" id="current-bugs-10">Current bugs</a></h6>
<ul>
<li>Use a different name;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>prepaid_gas() -&gt; u64
used_gas() -&gt; u64
<span class="boring">}
</code></pre></pre>
<h6><a class="header" href="#panics-31" id="panics-31">Panics</a></h6>
<ul>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h1><a class="header" href="#math-api" id="math-api">Math API</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>random_seed(register_id: u64)
<span class="boring">}
</code></pre></pre>
<p>Returns random seed that can be used for pseudo-random number generation in deterministic way.</p>
<h6><a class="header" href="#panics-32" id="panics-32">Panics</a></h6>
<ul>
<li>If the size of the registers exceed the set limit <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>sha256(value_len: u64, value_ptr: u64, register_id: u64)
<span class="boring">}
</code></pre></pre>
<p>Hashes the random sequence of bytes using sha256 and returns it into <code>register_id</code>.</p>
<h6><a class="header" href="#panics-33" id="panics-33">Panics</a></h6>
<ul>
<li>If <code>value_len + value_ptr</code> points outside the memory or the registers use more memory than the limit with <code>MemoryAccessViolation</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-11" id="current-bugs-11">Current bugs</a></h6>
<ul>
<li>Current name <code>hash</code> is not specific to what hash is being used.</li>
<li>We have <code>hash32</code> that largely duplicates the mechanics of <code>hash</code> because it returns the first 4 bytes only.</li>
</ul>
<h1><a class="header" href="#miscellaneous-api" id="miscellaneous-api">Miscellaneous API</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>value_return(value_len: u64, value_ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Sets the blob of data as the return value of the contract.</p>
<h6><a class="header" href="#panics-34" id="panics-34">Panics</a></h6>
<ul>
<li>If <code>value_len + value_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>panic()
<span class="boring">}
</code></pre></pre>
<p>Terminates the execution of the program with panic <code>GuestPanic(&quot;explicit guest panic&quot;)</code>.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>panic_utf8(len: u64, ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Terminates the execution of the program with panic <code>GuestPanic(s)</code>, where <code>s</code> is the given UTF-8 encoded string.</p>
<h6><a class="header" href="#normal-behavior" id="normal-behavior">Normal behavior</a></h6>
<p>If <code>len == u64::MAX</code> then treats the string as null-terminated with character <code>'\0'</code>;</p>
<h6><a class="header" href="#panics-35" id="panics-35">Panics</a></h6>
<ul>
<li>If string extends outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
<li>If string is not UTF-8 returns <code>BadUtf8</code>.</li>
<li>If string length without null-termination symbol is larger than <code>config.max_log_len</code> returns <code>BadUtf8</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>log_utf8(len: u64, ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Logs the UTF-8 encoded string.</p>
<h6><a class="header" href="#normal-behavior-1" id="normal-behavior-1">Normal behavior</a></h6>
<p>If <code>len == u64::MAX</code> then treats the string as null-terminated with character <code>'\0'</code>;</p>
<h6><a class="header" href="#panics-36" id="panics-36">Panics</a></h6>
<ul>
<li>If string extends outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
<li>If string is not UTF-8 returns <code>BadUtf8</code>.</li>
<li>If string length without null-termination symbol is larger than <code>config.max_log_len</code> returns <code>BadUtf8</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>log_utf16(len: u64, ptr: u64)
<span class="boring">}
</code></pre></pre>
<p>Logs the UTF-16 encoded string. <code>len</code> is the number of bytes in the string.
See https://stackoverflow.com/a/5923961 that explains that null termination is not defined through encoding.</p>
<h6><a class="header" href="#normal-behavior-2" id="normal-behavior-2">Normal behavior</a></h6>
<p>If <code>len == u64::MAX</code> then treats the string as null-terminated with two-byte sequence of <code>0x00 0x00</code>.</p>
<h6><a class="header" href="#panics-37" id="panics-37">Panics</a></h6>
<ul>
<li>If string extends outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>abort(msg_ptr: u32, filename_ptr: u32, line: u32, col: u32)
<span class="boring">}
</code></pre></pre>
<p>Special import kept for compatibility with AssemblyScript contracts. Not called by smart contracts directly, but instead
called by the code generated by AssemblyScript.</p>
<h1><a class="header" href="#future-improvements" id="future-improvements">Future Improvements</a></h1>
<p>In the future we can have some of the registers to be on the guest.
For instance a guest can tell the host that it has some pre-allocated memory that it wants to be used for the register,
e.g.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>set_guest_register(register_id: u64, register_ptr: u64, max_register_size: u64)
<span class="boring">}
</code></pre></pre>
<p>will assign <code>register_id</code> to a span of memory on the guest. Host then would also know the size of that buffer on guest
and can throw a panic if there is an attempted copying that exceeds the guest register size.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
